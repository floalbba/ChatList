# План реализации ChatList

Поэтапный порядок действий по реализации программы на основании PROJECT.md.

---

## Этап 1. Подготовка проекта

1.1. Обновить зависимости в `requirements.txt`:
- PyQt5
- httpx (или requests)
- python-dotenv (для .env)

1.2. Создать структуру модулей:
- `db.py` — работа с SQLite
- `models.py` — логика моделей
- `network.py` — HTTP-запросы к API
- `main.py` — GUI и точка входа

1.3. Создать файл `.env.example` с шаблоном переменных для API-ключей.

---

## Этап 2. База данных (db.py)

2.1. Реализовать инициализацию БД:
- Создание файла SQLite при первом запуске
- Выполнение миграций/создание таблиц

2.2. Реализовать CRUD для таблицы `prompts`:
- Создание, чтение, обновление, удаление промтов
- Поиск и сортировка (опционально)

2.3. Реализовать CRUD для таблицы `models`:
- Добавление, редактирование, удаление моделей
- Получение списка активных моделей (`is_active=1`)

2.4. Реализовать CRUD для таблицы `results`:
- Сохранение выбранных результатов
- Чтение сохранённых результатов

2.5. Реализовать работу с таблицей `settings`:
- Чтение и запись настроек (ключ-значение)

---

## Этап 3. Логика моделей (models.py)

3.1. Реализовать загрузку списка моделей из БД.

3.2. Реализовать получение API-ключа по `api_id` из переменных окружения (.env).

3.3. Реализовать формирование запросов к разным типам API (OpenAI, DeepSeek, Groq и т.д.) — базовая поддержка.

---

## Этап 4. Сетевой слой (network.py)

4.1. Реализовать функцию отправки промта в одну модель:
- HTTP POST к `api_url`
- Передача API-ключа из заголовков
- Обработка ответа и извлечение текста

4.2. Реализовать асинхронную/параллельную отправку в несколько моделей.

4.3. Добавить обработку ошибок (таймаут, 401, 500 и т.д.).

---

## Этап 5. Временная таблица результатов

5.1. Реализовать хранение временных результатов в памяти (список/словарь):
- model_name
- response_text
- selected (bool)

5.2. Реализовать очистку при новом запросе.

5.3. Реализовать сохранение выбранных строк в таблицу `results`.

---

## Этап 6. GUI — основной интерфейс (main.py)

6.1. Создать главное окно с разметкой:
- Область ввода промта (QTextEdit или QLineEdit)
- Список сохранённых промтов (QListWidget / QTableWidget) для выбора
- Кнопка «Отправить»
- Таблица результатов (QTableWidget) с колонками: модель, ответ, чекбокс
- Кнопка «Сохранить»

6.2. Реализовать ввод нового промта и выбор из сохранённых.

6.3. Реализовать отправку запроса:
- При нажатии «Отправить» — вызов network.py
- Отображение загрузки (спиннер, прогресс)
- Заполнение временной таблицы результатами

6.4. Реализовать чекбоксы в таблице для выбора строк.

6.5. Реализовать кнопку «Сохранить»:
- Запись выбранных строк в `results`
- Очистка временной таблицы

6.6. Реализовать очистку временной таблицы при вводе нового промта.

---

## Этап 7. Управление моделями (GUI)

7.1. Добавить экран/диалог настройки моделей:
- Список моделей с флажком is_active
- Добавление новой модели (name, api_url, api_id)
- Редактирование и удаление

7.2. Связать с db.py и models.py.

---

## Этап 8. Тестирование и доработка

8.1. Проверить полный цикл: промт → отправка → результаты → сохранение.

8.2. Проверить работу с пустым списком моделей.

8.3. Проверить обработку ошибок сети.

8.4. Обновить build.ps1 для сборки exe с новыми модулями.

---

## Этап 9. Опциональные функции

9.1. Поиск и сортировка во всех таблицах.

9.2. Экспорт выбранных результатов в Markdown / JSON.

9.3. Поддержка разных типов моделей (OpenAI, DeepSeek, Groq).

9.4. Логи запросов.

---

## Этап 10. AI-ассистент для улучшения промтов

План реализации функции из PROJECT.md, п. 7.

### 10.1. Модуль prompt_improver.py

10.1.1. Создать модуль `prompt_improver.py`:
- Функция `build_improvement_prompt(original_prompt: str, mode: str) -> str` — формирует системный промт для модели с инструкцией улучшить/переформулировать исходный текст.
- Режимы: `improve` (улучшение), `variants` (2–3 варианта), `adapt` (адаптация под код/анализ/креатив).

10.1.2. Реализовать функцию `improve_prompt(original: str, model: dict, mode: str) -> dict`:
- Вызывает `network.send_prompt_to_model` с подготовленным промтом.
- Парсит ответ модели (улучшенный промт, варианты через разделители).
- Возвращает структуру: `{improved: str, variants: list[str], adapted: dict[str, str]}`.

10.1.3. Шаблоны системных промтов:
- «Улучши промт для нейросети: …» — для режима improve.
- «Дай 2–3 варианта переформулировки: …» — для variants.
- «Адаптируй промт под: 1) код, 2) анализ, 3) креатив: …» — для adapt.

### 10.2. Сетевой слой (network.py)

10.2.1. Убедиться, что `send_prompt_to_model` поддерживает кастомные сообщения (system + user), если требуется.

10.2.2. При необходимости добавить `send_improvement_request(model, messages)` для запросов с системным промтом.

### 10.3. Выбор модели для ассистента

10.3.1. Добавить в `settings` ключ `improver_model_id` — ID модели по умолчанию для улучшения.
10.3.2. В диалоге «Улучшить промт» — выпадающий список активных моделей для выбора.

### 10.4. GUI — кнопка и диалог

10.4.1. Добавить кнопку «Улучшить промт» рядом с полем ввода промта.

10.4.2. Создать диалог `PromptImproverDialog`:
- Поле «Исходный промт» (read-only).
- Поле «Улучшенный промт» (результат).
- Список/вкладки «Альтернативные варианты» (2–3 шт.).
- Опционально: вкладка «Адаптация» (код, анализ, креатив).
- Кнопки «Подставить в поле ввода» для каждого варианта.
- Кнопка «Закрыть».

10.4.3. При нажатии «Улучшить промт»:
- Взять текст из `prompt_edit`.
- Показать диалог с индикатором загрузки.
- В фоне вызвать `improve_prompt` через QThread.
- По завершении — заполнить диалог результатами.

10.4.4. При нажатии «Подставить» — вставить выбранный текст в `prompt_edit` и закрыть диалог.

### 10.5. Обработка ошибок и краевых случаев

10.5.1. Пустой промт — предупреждение «Введите текст для улучшения».
10.5.2. Нет активных моделей — предупреждение.
10.5.3. Ошибка API — показать в диалоге сообщение об ошибке.

### 10.6. Порядок реализации

```
10.1 → 10.2 → 10.3 → 10.4 → 10.5
```

---

## Порядок зависимостей

```
Этап 1 → Этап 2 → Этап 3 → Этап 4 → Этап 5 → Этап 6 → Этап 7 → Этап 8 → Этап 9 → Этап 10
```

Этапы 2, 3, 4 можно частично распараллелить после завершения Этапа 2.
